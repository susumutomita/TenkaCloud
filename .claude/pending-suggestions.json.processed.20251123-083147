[
  {
    "category": "Personal Coding Style",
    "target_file": "/Users/susumu/TenkaCloud/.claude/developers/susumutomita.md",
    "content": "## コミュニケーションスタイル\n### 指示の出し方\n- **シンプルで直接的**: \"動きました。プルリクエスト作ってください。\"\n- **具体的なURL/パス提示**: Issue整理時に `https://github.com/susumutomita/TenkaCloud/issues` を明示\n- **問題を体験ベースで表現**: \"ローカルでテストしづらい体験になっている\"\n### 品質基準\n- **プロダクションレベル重視**: モックアップではなく、最初から本番品質のコードを求める\n- **開発者体験 (DX) の優先**: ローカル環境での動作確認のしやすさを重視\n- **完全性**: Issue の受け入れ基準をすべて満たすまでクローズしない姿勢",
    "timestamp": "2025-11-23 08:20"
  },
  {
    "category": "Project Rules",
    "target_file": "/Users/susumu/TenkaCloud/CLAUDE.md",
    "content": "## 環境構築とバージョン管理\n### Docker と ローカル環境のバージョン統一\n- **必須**: Dockerfile で使用する言語ランタイム（Bun、Node.js等）のバージョンをローカル環境と完全に一致させる\n- **lockfile の整合性**: バージョン不一致により lockfile エラーが発生するため、明示的にバージョンを固定する\n**例**:\n```dockerfile\n# ❌ NG: バージョンを指定しない\nFROM oven/bun:latest\n# ✅ OK: ローカル環境と同じバージョンを明示\nFROM oven/bun:1.2.20\n```\n## NextAuth + Keycloak 統合パターン\n### ログアウト処理のベストプラクティス\n- **問題**: `signOut()` 実行後、セッションがクリアされるため `idToken` が `undefined` になり、Keycloak への `id_token_hint` パラメータが渡せない\n- **解決**: `signOut()` 実行**前**に必要なセッションデータを変数に保存する\n**実装例**:\n```typescript\n// ✅ OK: signOut前にidTokenを保存\nconst currentSession = await auth();\nconst idToken = currentSession?.idToken;\nconst keycloakIssuer = process.env.AUTH_KEYCLOAK_ISSUER;\nawait signOut({ redirect: false });\nif (idToken && keycloakIssuer) {\n  // 保存したidTokenを使用してKeycloakログアウト\n  const logoutUrl = `${keycloakIssuer}/protocol/openid-connect/logout?id_token_hint=${idToken}&post_logout_redirect_uri=${encodedRedirectUri}`;\n  redirect(logoutUrl);\n}\n// ❌ NG: signOut後にidTokenを取得しようとする\nawait signOut({ redirect: false });\nconst currentSession = await auth(); // セッションは既にクリア済み\nif (currentSession?.idToken) { // undefined になる\n  // ...\n}\n```\n## Issue 管理ポリシー\n### Issue クローズの基準\n- **受け入れ基準 (Acceptance Criteria) をすべて満たした場合のみクローズ**\n- 部分実装の場合は Issue を開いたまま保持し、進捗をコメントで記録\n- マイルストーンを活用して MVP フェーズと Full Feature フェーズを区別\n## ローカル開発体験 (DX) 標準\n### make start コマンドの要件\n- **すべてのサービスが一度に起動する**: フロントエンド（Control Plane UI、Admin App、Participant App、Landing Page）、バックエンド、認証基盤（Keycloak）\n- **ローカルでの動作確認が容易**: 開発者が個別にサービスを起動する手間を省く\n- **ポート番号の明示**: README または Makefile に各サービスのポート番号を記載",
    "timestamp": "2025-11-23 08:20"
  },
  {
    "category": "Shared Knowledge",
    "target_file": "/Users/susumu/TenkaCloud/.claude/shared/troubleshooting-bun-docker-lockfile.md",
    "content": "\n# Bun + Docker: lockfile エラーのトラブルシューティング\n\n## 問題\n\nDocker ビルド時に以下のエラーが発生：\n\n```\nerror: lockfile had changes, but lockfile is frozen\nnote: try re-running without --frozen-lockfile and commit the updated lockfile\n```\n\n## 原因\n\nローカル環境の Bun バージョン（例: 1.2.20）と Docker イメージの Bun バージョン（例: 1.3.3）が異なるため、lockfile の形式に互換性がない。\n\n## 解決方法\n\n### 1. Docker イメージのバージョンを明示的に指定\n\n```dockerfile\n# ❌ NG: latest タグを使用\nFROM oven/bun:1\n\n# ✅ OK: ローカル環境と同じバージョンを明示\nFROM oven/bun:1.2.20\n```\n\n### 2. ローカル環境のバージョン確認\n\n```bash\nbun --version\n# 出力例: 1.2.20\n```\n\n### 3. Dockerfile の更新\n\n```dockerfile\nFROM oven/bun:1.2.20\n\nWORKDIR /app\n\nCOPY package.json bun.lock ./\nRUN bun install --frozen-lockfile\n\nCOPY . .\nRUN bun run build\n```\n\n### 4. 再ビルド\n\n```bash\ndocker compose build --no-cache\ndocker compose up\n```\n\n## 予防策\n\n- **バージョンを固定**: Dockerfile では常に特定のバージョンタグを使用（`:latest` や `:1` は避ける）\n- **.tool-versions または .nvmrc の活用**: Bun や Node.js のバージョンをリポジトリルートに記載\n- **CI でバージョンチェック**: ローカル環境と Docker 環境のバージョンが一致しているか自動検証\n\n## 関連リソース\n\n- [Bun Dockerfile Examples](https://bun.sh/docs/install/docker)\n- [Docker Multi-stage Builds](https://docs.docker.com/build/building/multi-stage/)\n### SHARED_KNOWLEDGE_END\n### SHARED_KNOWLEDGE_START\n\n# NextAuth + Keycloak: ログアウト時の \"Invalid parameter: id_token_hint\" エラー\n\n## 問題\n\nKeycloak からログアウトしようとすると、以下のエラーが表示される：\n\n```\nWe are sorry...\nInvalid parameter: id_token_hint\n```\n\n## 原因\n\nNextAuth の `signOut()` を実行すると、セッションがクリアされる。その後、セッションから `idToken` を取得しようとすると `undefined` になり、Keycloak のログアウトエンドポイントに `id_token_hint` パラメータを渡せない。\n\n## 解決方法\n\n### ❌ NG: signOut後にidTokenを取得\n\n```typescript\nexport async function logout() {\n  const currentSession = await auth();\n  \n  await signOut({ redirect: false }); // ここでセッションがクリア\n  \n  // ❌ currentSession.idToken は既に undefined\n  if (currentSession?.idToken && process.env.AUTH_KEYCLOAK_ISSUER) {\n    const logoutUrl = `${process.env.AUTH_KEYCLOAK_ISSUER}/protocol/openid-connect/logout?id_token_hint=${currentSession.idToken}`;\n    redirect(logoutUrl);\n  }\n  \n  redirect(\"/\");\n}\n```\n\n### ✅ OK: signOut前にidTokenを保存\n\n```typescript\nexport async function logout() {\n  const currentSession = await auth();\n  \n  // ✅ signOut実行前にidTokenを変数に保存\n  const idToken = currentSession?.idToken;\n  const keycloakIssuer = process.env.AUTH_KEYCLOAK_ISSUER;\n  \n  await signOut({ redirect: false });\n  \n  // ✅ 保存したidTokenを使用\n  if (idToken && keycloakIssuer) {\n    const redirectUri = process.env.NEXTAUTH_URL || \"http://localhost:3000\";\n    const encodedRedirectUri = encodeURIComponent(redirectUri);\n    const logoutUrl = `${keycloakIssuer}/protocol/openid-connect/logout?id_token_hint=${idToken}&post_logout_redirect_uri=${encodedRedirectUri}`;\n    redirect(logoutUrl);\n  }\n  \n  redirect(\"/\");\n}\n```\n\n## ポイント\n\n1. **セッションデータの事前保存**: `signOut()` を実行する前に、必要なセッションデータ（`idToken` など）を変数に保存\n2. **Keycloakログアウトパラメータ**:\n   - `id_token_hint`: ログアウトするユーザーを識別するための ID トークン（必須）\n   - `post_logout_redirect_uri`: ログアウト後のリダイレクト先（任意）\n\n## 関連リソース\n\n- [NextAuth.js: Server-side signOut](https://next-auth.js.org/getting-started/client#signout)\n- [Keycloak: Logout Endpoint](https://www.keycloak.org/docs/latest/securing_apps/index.html#logout)",
    "timestamp": "2025-11-23 08:20"
  }
]
